<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>events/mapVoting.js - SquadStatJSPRO</title>
    
    <meta name="description" content="Discord bot and website statistics for your game server (Squad)" />
    
        <meta name="keywords" content="squad, squadjs, stats, leaderboard, discord, website" />
        <meta name="keyword" content="squad, squadjs, stats, leaderboard, discord, website" />
    
    
    
    <meta property="og:title" content=""/>
    <meta property="og:type" content="website"/>
    <meta property="og:image" content=""/>
    
    <meta property="og:url" content=""/>
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav class="wrap">
    
    <input type="text" id="nav-search" placeholder="Search" />
    
    <h2><a href="index.html">Home</a></h2><h2><a href="https://github.com/11TStudio/SquadStatsJSPRO" target="_blank" class="menu-item" id="website_link" >Project Website</a></h2><h2><a href="https://discord.gg/9F2Ng5C" target="_blank" class="menu-item" id="discord_link" >Discord</a></h2><h3>Classes</h3><ul><li><a href="MapVote.html">MapVote</a></li><li></li><li><a href="MYSQLPromiseObjectBuilder.html">MYSQLPromiseObjectBuilder</a><ul class='methods'><li data-type='method' style='display: none;'><a href="MYSQLPromiseObjectBuilder.html#add">add</a></li><li data-type='method' style='display: none;'><a href="MYSQLPromiseObjectBuilder.html#waitForAll">waitForAll</a></li></ul></li><li><a href="Squad-Configure-Connection.html">Squad-Configure-Connection</a></li><li><a href="Squad-Track-Profile.html">Squad-Track-Profile</a></li><li></li></ul><h3>Global</h3><ul><li><a href="global.html#dateTimePad">dateTimePad</a></li><li><a href="global.html#drawMaps">drawMaps</a></li><li><a href="global.html#drawText">drawText</a></li><li><a href="global.html#drawWinner">drawWinner</a></li><li><a href="global.html#embedBuilder">embedBuilder</a></li><li><a href="global.html#format">format</a></li><li><a href="global.html#removeMap">removeMap</a></li><li><a href="global.html#walkDirectory">walkDirectory</a></li><li><a href="global.html#wrapText">wrapText</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">events/mapVoting.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const Discord = require("discord.js"),
	{ MessageEmbed } = require("discord.js"),
	axios = require("axios"),
	io = require("socket.io-client"),
	Canvas = require("canvas"),
	{ resolve } = require("path"),
	random = require("random"),
	MYSQLPromiseObjectBuilder = require("../base/MYSQLPromiseObjectBuilder.js");

const wait = require("util").promisify(setTimeout);
const mysql = require("mysql");
// Register assets fonts
Canvas.registerFont(resolve("./assets/fonts/theboldfont.ttf"), {
	family: "Bold",
});
Canvas.registerFont(resolve("./assets/fonts/SketchMatch.ttf"), {
	family: "SketchMatch",
});

const canvasVotes = Canvas.createCanvas(1680, 1080),
	ctx = canvasVotes.getContext("2d");

const canvasLayers = Canvas.createCanvas(1680, 1080),
	ctxLayers = canvasLayers.getContext("2d");

const canvasWinner = Canvas.createCanvas(1680, 1080),
	ctxWinner = canvasWinner.getContext("2d");

const config = require("../config.js"),
	DEBUG = config.support.debug,
	ip = config.squadMapVoting.socketIO.ip,
	port = config.squadMapVoting.socketIO.port,
	token = config.squadMapVoting.socketIO.token,
	seedLayers = config.squadMapVoting.layers.seedLayers,
	rotationLayers = config.squadMapVoting.layers.normalLayers,
	votingTime = config.squadMapVoting.votingTime,
	seedThreeshold = config.squadMapVoting.seedThreeshold,
	mapBeginTimeout = config.squadMapVoting.messages.mapBeginTimeout,
	keepHistoryOfLayers = config.squadMapVoting.keepHistoryOfLayers;

const defEmojiList = [
	"\u0031\u20E3",
	"\u0032\u20E3",
	"\u0033\u20E3",
	"\u0034\u20E3",
	"\u0035\u20E3",
	"\u0036\u20E3",
];
let currentPlayers;
let res;
let testData;
let ignoreMaps = [];
let rotationToUse;
let response;
let text;
let voter = [];
let votedTo = [];
let winner = "";
let winAmount = 0;
let totalVotesAmount = 0;
let loopSize;
let emojiInfoLayers = {};
let tempMax;
let gameLayerImg;
let voteForLayer;
let winnerImg;
let maps = [];
let mapsName = [];
let pickedMaps = [];
let pickedMapsName = [];
let layer;
let layers = [];
let width = 0;
let layerName;
let currentLayer;
let index;
let Layer = {
	1: [],
	2: [],
	3: [],
	4: [],
	5: [],
	6: [],
};
let found;

/**Builds an embed message.
 *
 * @param {String} title - The title of the embed message
 * @returns {MessageEmbed} Discord embed message
 */
const embedBuilder = (title) => {
	return new MessageEmbed().setTitle(`${title}`);
};

/**Removes the map from the array of maps
 *
 * @param {Array} arr - An array of maps.
 * @param {String} value - A map.
 * @returns {Array} - The filtered array.
 */
function removeMap(arr, value) {
	return arr.filter(function (ele) {
		return ele != value;
	});
}

/** Draws layers and their sequence numbers to canvas.
 *
 * @param {Array} maps - An array of 6 raw names of the random layers.
 * @param {Array} names - An array of 6 human readable layer names.
 * @returns {null} - Logs an error in the console.
 * @author LeventHAN
 */
async function drawMaps(maps, names) {
	/**Centers the text
	 *
	 * @param {String} text - The content to be centered
	 * @returns {Integer} Width/ Y coordinates
	 * @author Alverrt
	 */
	const alignText = (text) => {
		const maptxt = ctxLayers.measureText(text);
		return (400 - maptxt.width) / 2;
	};

	if (!names) return console.error("No object.");
	layers = [];
	for (let i = 0; i &lt; maps.length; i++) {
		layer = await Canvas.loadImage(
			`https://raw.githubusercontent.com/Squad-Wiki-Editorial/squad-wiki-pipeline-map-data/master/completed_output/_Current%20Version/images/${maps[i]}.jpg`
		);
		await layers.push(layer);
	}

	// Draw layer's images
	width = 0;
	for (let i = 0; i &lt; names.length; i++) {
		if (i &lt;= 2) {
			await ctxLayers.drawImage(layers[i], 120 + width, 90, 400, 400);
			ctxLayers.font = "42px Bold";
			ctxLayers.fillStyle = "#fcfc03";
			await ctxLayers.fillText(
				names[i],
				120 + width + alignText(names[i]),
				540
			);
			ctxLayers.font = "64px Sans-serif";
			ctxLayers.strokeStyle = "black";
			ctxLayers.lineWidth = 6;
			ctxLayers.fillStyle = "#f56c42";
			ctxLayers.strokeText(i + 1, 460 + width, 460);
			ctxLayers.fillText(i + 1, 460 + width, 460);
			i == 2 ? (width = 0) : (width += 520);
		}
		if (i > 2) {
			await ctxLayers.drawImage(layers[i], 120 + width, 580, 400, 400);
			ctxLayers.font = "42px Bold";
			ctxLayers.fillStyle = "#fcfc03";
			await ctxLayers.fillText(
				names[i],
				120 + width + alignText(names[i]),
				1030
			);
			ctxLayers.font = "64px Sans-serif";
			ctxLayers.strokeStyle = "black";
			ctxLayers.lineWidth = 6;
			ctxLayers.fillStyle = "#f56c42";
			ctxLayers.strokeText(i + 1, 460 + width, 950);
			ctxLayers.fillText(i + 1, 460 + width, 950);
			width += 520;
		}
	}
}

/** Draws the winning layer's image in the canvas.
 *
 * @param {string} winner - The layer that has the most votes.
 * @param {number} winAmount - The amount of votes.
 * @param {number} totalVotesAmount - The total votes.
 * @author LeventHAN
 * @author Alverrt
 */
async function drawWinner(winner, winAmount, totalVotesAmount) {
	/** Draws the winning layer's image in the canvas.
	 *
	 * @param {string} text - The content to center.
	 * @author Alverrt
	 * @returns {number} The width to center the text.
	 */
	const alignText = (text) => {
		const maptxt = ctxWinner.measureText(text);
		return (400 - maptxt.width) / 2;
	};
	layerName = winner;
	currentLayer = winner.replace(/'/g, "");
	currentLayer = currentLayer.replace(/ /g, "_");
	const imgLayer = await Canvas.loadImage(
		`https://raw.githubusercontent.com/Squad-Wiki-Editorial/squad-wiki-pipeline-map-data/master/completed_output/_Current%20Version/images/${currentLayer}.jpg`
	);

	// draw map images
	ctxWinner.font = "70px Bold";
	ctxWinner.fillStyle = "#fcfc03";

	await ctxWinner.drawImage(imgLayer, 510, 140, 700, 700);

	await ctxWinner.fillText(layerName, 660 + alignText(layerName), 930);

	ctxWinner.font = "60px Bold";
	ctxWinner.fillStyle = "#fa9024";

	await ctxWinner.fillText(
		`Won with ${winAmount} votes out of ${totalVotesAmount} votes`,
		660 +
			alignText(`Won with ${winAmount} votes out of ${totalVotesAmount} votes`),
		1000
	);
}

/**Event for mapvoting.
 * &lt;h2>Usage: &lt;/h2>
 * &lt;h3>Catches NEW_GAME event that has been fired via socket-io-server&lt;/h3>
 *
 * @author LeventHAN
 * @class MapVote
 * @extends Command
 */
module.exports = class {
	constructor(client) {
		this.client = client;
		this.pool = null;
	}

	async run(guildID, channelID) {
		const client = this.client;
		const channel = client.channels.cache.find(
			(channel) => channel.id === channelID
		);
		const regex = /\d+/gm;
		const guildData = await this.client.findOrCreateGuild({ id: guildID });
		const socket = io.connect("ws://" + ip + ":" + port, {
			auth: {
				token: token,
			},
		});

		socket.on("connect_error", (err) => {
			return client.logger.log(err, "ERROR");
		});

		if (socket)
			client.logger.log(
				`Socket.IO is successfully connected with ${ip}:${port}`,
				"READY"
			);

		socket.on("NEW_GAME", async () => {
			await wait(mapBeginTimeout * 1000);
			if (!guildData.plugins.squad.mapVote.enabled)
				return client.logger.log("Map voting is manually disabled.", "DEBUG");

			if (DEBUG) {
				client.logger.log("Players amount is asked.", "DEBUG");
			} else {
				await socket.emit("players", (playerList) => {
					currentPlayers = playerList.length;
					client.logger.log(
						`Current Players after waiting ${
							mapBeginTimeout
						} seconds is ${currentPlayers}`,
						"DEBUG"
					);
				});
			}

			if (this.pool == null) {
				// Only create one instance
				this.pool = mysql.createPool({
					connectionLimit: 10, // Call all
					host: guildData.plugins.squad.host,
					port: guildData.plugins.squad.port,
					user: guildData.plugins.squad.user,
					password: guildData.plugins.squad.password,
					database: guildData.plugins.squad.database,
				});
			}
			const pool = this.pool;
			res = new MYSQLPromiseObjectBuilder(pool);

			// TODO: make this query dynamic
			for (let i = 0; i &lt; keepHistoryOfLayers; i++) {
				res.add(
					`ignoreLayer_${i}`,
					`SELECT map AS MAP
				FROM DBLog_Matches
				ORDER BY startTime desc
				LIMIT 1 OFFSET ${i}`,
					"Undefined",
					null
				);
			}
			testData = await res.waitForAll();
			ignoreMaps = [];
			ignoreMaps.push(testData.ignoreLayer_0.MAP);
			ignoreMaps.push(testData.ignoreLayer_1.MAP);
			ignoreMaps.push(testData.ignoreLayer_2.MAP);
			ignoreMaps.push(testData.ignoreLayer_3.MAP);

			response = await axios.get(
				"https://raw.githubusercontent.com/Squad-Wiki-Editorial/squad-wiki-pipeline-map-data/master/completed_output/_Current%20Version/finished.json"
			);

			// Background language
			const background = await Canvas.loadImage(
				"./assets/img/mapvote_background.jpg"
			);
			// This uses the canvas dimensions to stretch the image onto the entire canvas
			await ctx.drawImage(
				background,
				0,
				0,
				canvasVotes.width,
				canvasVotes.height
			);

			maps = [];
			mapsName = [];
			pickedMaps = [];
			pickedMapsName = [];
			rotationToUse =
				currentPlayers > seedThreeshold ? rotationLayers : seedLayers;

			response.data.Maps.forEach((map) => {
				if (
					!ignoreMaps.includes(map.mapName) &amp;&amp;
					rotationToUse.includes(map.rawName)
				) {
					maps.push(map.Name);
					mapsName.push(map.rawName);
					ignoreMaps.push(map.mapName);
				}
			});
			loopSize = maps.length > 6 ? 6 : maps.length;
			for (let i = 0; i &lt; loopSize; i++) {
				index = random.int(0, maps.length - 1);
				if (!maps[index]) continue;
				if (!mapsName[index]) continue;
				pickedMaps.push(mapsName[index]);
				pickedMapsName.push(maps[index]);
				mapsName = removeMap(mapsName, mapsName[index]);
				maps = removeMap(maps, maps[index]);
			}

			text = client.translate("misc/EMBED_DESC", {
				seconds: votingTime,
			});

			// This uses the canvas dimensions to stretch the image onto the entire canvas
			await ctxLayers.drawImage(
				background,
				0,
				0,
				canvasLayers.width,
				canvasLayers.height
			);

			await drawMaps(pickedMaps, pickedMapsName);
			if (DEBUG) {
				client.logger.log("Voting started message has been send..", "DEBUG");
			} else {
				socket.emit(
					"rcon.broadcast",
					this.client.translate("misc/VOTING_STARTED_BROADCAST"),
					() => {
					}
				);
			}

			const emojiListLayers = defEmojiList.slice();
			emojiInfoLayers = {};
			tempMax = loopSize;
			for (const option of pickedMapsName) {
				if (tempMax &lt;= 0) continue;
				const emoji = emojiListLayers.splice(0, 1);
				emojiInfoLayers[emoji] = { option: option, votes: 0 };
				text += `${emoji} : \`${option}\`\n\n`;
				tempMax--;
			}

			gameLayerImg = await new Discord.MessageAttachment(
				canvasLayers.toBuffer(),
				"mapGameLayerVote.png"
			);

			voteForLayer = await channel.send(
				embedBuilder(client.translate("misc:MAP_VOTE_LAYER_TITLE"))
					.setDescription(text)
					.setColor(config.embed.color)
					.setFooter(config.embed.footer)
					.setTimestamp()
					.attachFiles(gameLayerImg)
					.setImage("attachment://mapGameLayerVote.png")
			);

			guildData.plugins.squad.mapVote.active = true;
			guildData.markModified("plugins.squad");
			await guildData.save();
			Layer = {
				1: [],
				2: [],
				3: [],
				4: [],
				5: [],
				6: [],
			};
			let string = "";
			for (let i = 1; i &lt;= pickedMapsName.length; i++) {
				string += `| [${i}] ${pickedMapsName[i - 1]} |`;
			}

			if(DEBUG){
				client.logger.log("Voting is starting. Vote by writing ONLY the number of the layer you want to be played next!", "DEBUG");
			} else {
				await socket.emit(
					"rcon.broadcast",
					"Voting is starting. Vote by writing ONLY the number of the layer you want to be played next!",
					() => {
					}
				);
				await wait(5 * 1000);
				await socket.emit("rcon.broadcast", string, () => {});
			}
			voter = [];
			votedTo = [];
			winner = "";
			winAmount = 0;
			socket.on("CHAT_MESSAGE", async (message) => {
				if (!guildData.plugins.squad.mapVote.active) return;
				found = message.message.match(regex);
				if (DEBUG)
					client.logger.log(`[${message.name}] - ${message.message}`, "DEBUG");
				if (!found) return;
				switch (found[0]) {
				case "1":
				case "2":
				case "3":
				case "4":
				case "5":
				case "6":
					if (voter.includes(message.name)) return;
					await voter.push(message.name);
					await votedTo.push(found);
					Layer[found].push(message.name || message.steamID);
					if (DEBUG)
						client.logger.log(
							`${message.name} did vote for ${found}`,
							"DEBUG"
						);
					await socket.emit(
						"rcon.execute",
						`AdminWarn ${
							message.steamID
						} Voting has been saved. You voted for; ${
							pickedMapsName[found - 1]
						}. SquadStatsJSPROâ„¢`,
						() => {
						}
					);
					break;
				default:
					if (DEBUG)
						client.logger.log(
							`Player did write another digit; ${found}`,
							"DEBUG"
						);
				}
			});

			if(DEBUG){
				client.logger.log(
					"Sending 3 time broadcast message with the layer names.",
					"DEBUG"
				);
			} else {
				await wait(votingTime/3 * 1000);
				await socket.emit("rcon.broadcast", string, () => {
				});
				await wait(votingTime/3 * 1000);
				await socket.emit("rcon.broadcast", string, () => {
				});
				await wait((votingTime/3) * 1000);
			}

			guildData.plugins.squad.mapVote.active = false;
			guildData.markModified("plugins.squad");
			await guildData.save();
			await voteForLayer.delete();

			await ctxWinner.drawImage(
				background,
				0,
				0,
				canvasWinner.width,
				canvasWinner.height
			);

			winAmount = 0;
			totalVotesAmount = 0;

			for (let i = 1; i &lt;= 6; i++) {
				if (!Layer[i]) continue;
				totalVotesAmount += Layer[i].length;
				if (winAmount &lt; Layer[i].length) {
					winAmount = Layer[i].length;
					winner = pickedMaps[i - 1];
				}
			}
			if (!winner) {
				winner = pickedMaps[0];
			}

			await drawWinner(winner, winAmount, totalVotesAmount);

			if (DEBUG) {
				channel.send(`AdminSetNextLayer ${winner}`);
			} else {
				socket.emit("rcon.execute", `AdminSetNextLayer ${winner}`, (s) => {
					client.logger.log(
						`${s}`,
						"DEBUG"
					);
				});
			}

			winnerImg = await new Discord.MessageAttachment(
				canvasWinner.toBuffer(),
				"mapWinner.png"
			);

			if (DEBUG) {
				channel.send(`Winning layer is ${winner} - with ${winAmount} votes.`);
			} else {
				socket.emit(
					"rcon.broadcast",
					client.translate("misc/WON_MESSAGE", {
						winner: winner,
						winAmount: winAmount,
					}) + `(${totalVotesAmount} total votes)`,
					() => {
						client.logger.log(
							`Winner map has been selected; ${winner} | votes; ${winAmount}. (${totalVotesAmount} total votes) `,
							"DEBUG"
						);
					}
				);
			}

			await channel.send(
				embedBuilder(
					client.translate("misc:WINNER_TITLE", {
						layer: winner,
					})
				)
					.setDescription(
						client.translate("misc:WINNER_DESC", {
							layer: winner,
							amount: winAmount,
						})
					)
					.setColor(config.embed.color)
					.setFooter(config.embed.footer)
					.setTimestamp()
					.attachFiles(winnerImg)
					.setImage("attachment://mapWinner.png")
			);
		});
	}
};
</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.6</a> on Wed May 19 2021 14:32:47 GMT+0200 (Orta Avrupa Yaz Saati) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>

<script src="scripts/search.js" defer></script>


<script src="scripts/collapse.js" defer></script>


</body>
</html>
